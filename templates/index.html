<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS 3000 • COSMIC AGI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            min-height: 100vh;
            color: #00ffff;
            overflow-x: hidden;
            position: relative;
            cursor: none;
        }
        
        /* Custom Cosmic Cursor */
        .cosmic-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.8), transparent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.1s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        /* Enhanced Space Background with Parallax */
        .space-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 120%;
            height: 120%;
            background: 
                radial-gradient(ellipse at 20% 30%, #1a0033 0%, transparent 50%), 
                radial-gradient(ellipse at 80% 70%, #0d1421 0%, transparent 50%), 
                radial-gradient(ellipse at 40% 80%, #2d1b69 0%, transparent 60%), 
                radial-gradient(ellipse 1200px 400px at 30% 20%, rgba(0, 212, 255, 0.4) 0%, transparent 40%), 
                radial-gradient(ellipse 800px 300px at 70% 60%, rgba(255, 0, 110, 0.3) 0%, transparent 35%), 
                radial-gradient(ellipse 1000px 200px at 50% 90%, rgba(131, 56, 236, 0.25) 0%, transparent 45%), 
                linear-gradient(125deg, #000011 0%, #0a0a0f 30%, #1a0033 60%, #000022 100%);
            animation: galaxyRotation 300s linear infinite;
            z-index: -10;
            transform: translate(-10%, -10%);
        }
        
        /* Advanced Starfield with Multiple Layers */
        .stars-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -8;
        }
        
        .stars-distant {
            background-image: 
                radial-gradient(1px 1px at 120px 80px, #ffffff, transparent), 
                radial-gradient(1px 1px at 350px 200px, #00f5ff, transparent), 
                radial-gradient(2px 2px at 580px 120px, #ffffff, transparent), 
                radial-gradient(1px 1px at 750px 300px, #ff1b8d, transparent), 
                radial-gradient(1px 1px at 200px 400px, #8338ec, transparent);
            background-size: 1200px 600px;
            animation: starfieldSlow 400s linear infinite;
            opacity: 0.6;
        }
        
        .stars-mid {
            background-image: 
                radial-gradient(2px 2px at 300px 150px, #00d4ff, transparent), 
                radial-gradient(2px 2px at 600px 350px, #ffffff, transparent), 
                radial-gradient(3px 3px at 150px 250px, #ff006e, transparent), 
                radial-gradient(2px 2px at 800px 100px, #8338ec, transparent);
            background-size: 800px 400px;
            animation: starfieldMid 250s linear infinite;
            opacity: 0.8;
        }
        
        .stars-near {
            background-image: 
                radial-gradient(3px 3px at 400px 200px, #00ffff, transparent), 
                radial-gradient(4px 4px at 700px 400px, #ffffff, transparent), 
                radial-gradient(3px 3px at 100px 300px, #ff1b8d, transparent);
            background-size: 600px 300px;
            animation: starfieldFast 150s linear infinite, starTwinkle 3s ease-in-out infinite alternate;
        }
        
        /* Alien Silhouettes in Distance */
        .alien-silhouettes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -7;
            opacity: 0.15;
        }
        
        .alien-ship {
            position: absolute;
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(255, 0, 255, 0.2));
            border-radius: 50%;
            animation: alienDrift 60s ease-in-out infinite;
        }
        
        .alien-ship-1 {
            width: 80px;
            height: 20px;
            top: 20%;
            left: 10%;
            animation-delay: 0s;
            border-radius: 40px/10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
        }
        
        .alien-ship-2 {
            width: 60px;
            height: 15px;
            top: 60%;
            right: 15%;
            animation-delay: -20s;
            border-radius: 30px/8px;
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.3);
        }
        
        .alien-ship-3 {
            width: 100px;
            height: 25px;
            top: 40%;
            left: 70%;
            animation-delay: -40s;
            border-radius: 50px/12px;
            box-shadow: 0 0 35px rgba(131, 56, 236, 0.4);
        }
        
        /* Comets */
        .comet {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 20px #00ffff;
        }
        
        .comet::after {
            content: '';
            position: absolute;
            top: 50%;
            right: 100%;
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.8), rgba(0, 255, 255, 0.3));
            transform: translateY(-50%);
            border-radius: 2px;
        }
        
        .comet-1 {
            top: 20%;
            left: -100px;
            animation: cometTrail 15s linear infinite;
        }
        
        .comet-2 {
            top: 70%;
            left: -100px;
            animation: cometTrail 20s linear infinite 8s;
        }
        
        /* Enhanced Planets with Rotation */
        .planets-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -6;
        }
        
        .planet {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 50px -10px currentColor, inset 0 0 25px -5px rgba(255, 255, 255, 0.4);
            background-blend-mode: multiply;
        }
        
        .planet::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.2) 50%, transparent 70%);
            animation: planetRotate 30s linear infinite;
        }
        
        .planet-1 {
            width: 280px;
            height: 280px;
            color: #ff4848;
            background: radial-gradient(circle at 30% 30%, rgba(255, 200, 200, 0.6), #c43a3a);
            animation: move-planet-1 120s linear infinite;
        }
        
        .planet-2 {
            width: 140px;
            height: 140px;
            color: #48aaff;
            background: radial-gradient(circle at 70% 70%, rgba(200, 230, 255, 0.5), #3a8bc4);
            animation: move-planet-2 180s linear infinite -30s;
        }
        
        .planet-3 {
            width: 80px;
            height: 80px;
            color: #e3d2ff;
            background: radial-gradient(circle at 20% 80%, rgba(255, 255, 255, 0.4), #a370ff);
            animation: move-planet-3 90s linear infinite;
        }
        
        /* Main Content Container */
        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            z-index: 10;
        }
        
        /* Enhanced Title */
        .title {
            font-size: 5em;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 15px;
            animation: glow 3s ease-in-out infinite alternate, gradientShift 6s ease-in-out infinite;
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 40px rgba(0, 255, 255, 0.9);
            position: relative;
        }
        
        .title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: titleUnderline 2s ease-in-out infinite alternate;
        }
        
        .subtitle {
            font-size: 1.6em;
            color: #00ffff;
            letter-spacing: 8px;
            margin-bottom: 40px;
            animation: pulse 2s infinite;
            text-align: center;
            text-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            font-weight: bold;
        }
        
        /* Full Body Robot Container */
        .robot-body-container {
            width: 300px;
            height: 450px;
            margin: 30px 0;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }
        
        /* Robot Head (Enhanced from original) */
        .robot-head {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.15), rgba(0, 0, 0, 0.9));
            border: 3px solid #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6), inset 0 0 20px rgba(0, 255, 255, 0.1);
            position: relative;
            margin-bottom: 10px;
            animation: headFloat 4s ease-in-out infinite;
        }
        
        /* Robot Body */
        .robot-torso {
            width: 100px;
            height: 150px;
            background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border: 3px solid #00ffff;
            border-radius: 15px;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.1);
            margin-bottom: 15px;
            animation: torsoGlow 3s ease-in-out infinite alternate;
        }
        
        .robot-torso::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #00ffff, transparent);
            border-radius: 50%;
            animation: chestLight 2s ease-in-out infinite;
        }
        
        /* Robot Arms */
        .robot-arms {
            position: absolute;
            top: 140px;
            width: 200px;
            height: 80px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .robot-arm {
            width: 15px;
            height: 80px;
            background: linear-gradient(180deg, #2a2a4e, #1a1a3e);
            border: 2px solid #00ffff;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .robot-arm.left {
            animation: leftArmMove 6s ease-in-out infinite;
            transform-origin: top center;
        }
        
        .robot-arm.right {
            animation: rightArmMove 8s ease-in-out infinite;
            transform-origin: top center;
        }
        
        .robot-hand {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
            animation: handGlow 2s ease-in-out infinite alternate;
        }
        
        /* Robot Legs */
        .robot-legs {
            display: flex;
            gap: 20px;
            margin-top: 5px;
        }
        
        .robot-leg {
            width: 20px;
            height: 120px;
            background: linear-gradient(180deg, #2a2a4e, #1a1a3e);
            border: 2px solid #00ffff;
            border-radius: 10px;
            position: relative;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .robot-leg.left {
            animation: leftLegWalk 4s ease-in-out infinite;
            transform-origin: top center;
        }
        
        .robot-leg.right {
            animation: rightLegWalk 4s ease-in-out infinite 2s;
            transform-origin: top center;
        }
        
        .robot-foot {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 15px;
            background: #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }
        
        /* Enhanced Robot Eyes for Full Body */
        .robot-eyes-fullbody {
            display: flex;
            justify-content: space-between;
            width: 50px;
            margin: 0 auto;
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .robot-eye-fullbody {
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, #000 30%, #00ffff 35%, #00aaff 100%);
            border-radius: 50%;
            box-shadow: 0 0 15px #00ffff, inset 0 0 8px rgba(255, 255, 255, 0.3);
            animation: eyePulse 2s ease-in-out infinite;
            position: relative;
        }
        
        .robot-eye-fullbody::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            width: 4px;
            height: 4px;
            background: #000;
            border-radius: 50%;
            animation: pupilMove 4s ease-in-out infinite;
        }
        
        /* Enhanced Robot Ears for Full Body */
        .robot-ears-fullbody {
            position: absolute;
            top: 35px;
            width: 100%;
            height: 30px;
        }
        
        .robot-ear-fullbody {
            position: absolute;
            width: 12px;
            height: 25px;
            background: linear-gradient(45deg, #333, #00ffff);
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .robot-ear-fullbody.left {
            left: 10px;
            transform: rotate(-15deg);
        }
        
        .robot-ear-fullbody.right {
            right: 10px;
            transform: rotate(15deg);
        }
        
        .robot-ear-fullbody.listening {
            animation: earListening 1s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        
        /* Enhanced Robot Mouth for Full Body */
        .robot-mouth-fullbody {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 12px;
            background: #000;
            border: 2px solid #00ffff;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        .mouth-indicator-fullbody {
            width: 100%;
            height: 100%;
            background: #00ffff;
            border-radius: 20px;
            transform: scaleY(0.2);
            transition: all 0.05s ease;
        }
        
        /* Idle Animations */
        .robot-activity {
            position: absolute;
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            opacity: 0;
            animation: activityFloat 3s ease-in-out infinite;
        }
        
        /* Robot Movement Container */
        .robot-movement-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .floating-robot {
            position: absolute;
            animation: robotWalkAround 30s linear infinite;
            opacity: 0.7;
            transform: scale(0.6);
        }
        
        /* Voice Status Ring */
        .voice-status-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 320px;
            height: 320px;
            border: 2px solid transparent;
            border-radius: 50%;
            z-index: 1;
        }
        
        .voice-status-ring.listening {
            border-color: rgba(0, 255, 255, 0.6);
            animation: ringPulse 2s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
        }
        
        .voice-status-ring.thinking {
            border-color: rgba(131, 56, 236, 0.6);
            animation: ringThinking 1s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(131, 56, 236, 0.4);
        }
        
        .voice-status-ring.speaking {
            border-color: rgba(216, 112, 240, 0.6);
            animation: ringSpeaking 0.3s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(216, 112, 240, 0.4);
        }
        
        /* Constellation Pattern Behind Robot */
        .constellation-bg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            opacity: 0.3;
            z-index: -1;
        }
        
        .constellation-dot {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .constellation-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, #00ffff, transparent);
            opacity: 0.6;
        }
        
        /* Enhanced Wave Container */
        .wave-container {
            width: 700px;
            height: 140px;
            position: relative;
            margin: 40px 0;
            background: rgba(0, 0, 0, 0.4);
            border: 3px solid #00ffff;
            border-radius: 25px;
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.4), 
                inset 0 0 50px rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .wave-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            animation: waveScan 3s ease-in-out infinite;
        }
        
        .wave-line {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 255, 0.3);
            transform: translateY(-50%);
            border-radius: 2px;
        }
        
        .wave-active {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 6px;
            background: #00ffff;
            transform: translateY(-50%);
            border-radius: 3px;
            transition: all 0.1s ease;
            box-shadow: 0 0 30px currentColor;
        }
        
        /* Status Indicator Enhancement */
        .status-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ffff;
            border-radius: 35px;
            padding: 15px 30px;
            font-size: 18px;
            color: #00ffff;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
            backdrop-filter: blur(20px);
            z-index: 100;
            opacity: 0;
            transition: all 0.3s ease;
            font-weight: bold;
            min-width: 200px;
            text-align: center;
        }
        
        .status-indicator::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ffff);
            border-radius: 35px;
            z-index: -1;
            animation: borderGlow 2s ease-in-out infinite alternate;
        }
        
        .status-indicator.show { opacity: 1; }
        
        /* Start Overlay Enhancement */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(15px);
            cursor: pointer;
            transition: opacity 0.5s ease;
        }
        
        #start-button {
            font-family: 'Courier New', monospace;
            font-size: 2em;
            color: #00ffff;
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
            border: 4px solid #00ffff;
            padding: 30px 60px;
            border-radius: 20px;
            cursor: pointer;
            text-shadow: 0 0 25px #00ffff;
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.5), 
                inset 0 0 30px rgba(0, 255, 255, 0.1);
            animation: holoPulse 2s infinite;
            text-transform: uppercase;
            letter-spacing: 4px;
            position: relative;
            overflow: hidden;
        }
        
        #start-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        #start-button:hover::before {
            left: 100%;
        }
        
        /* Enhanced mouth animations for full body */
        .mouth-indicator-fullbody.listening {
            background: #00ffff;
            animation: mouthListening 1s ease-in-out infinite;
        }
        
        .mouth-indicator-fullbody.user-speaking {
            background: #00aaff;
            animation: mouthUserSpeaking 0.15s ease-in-out infinite;
        }
        
        .mouth-indicator-fullbody.ai-speaking, .mouth-indicator-fullbody.speaking {
            background: #d870f0;
            animation: mouthAISpeaking 0.2s ease-in-out infinite;
        }
        
        .mouth-indicator-fullbody.thinking {
            background: #8338ec;
            animation: mouthThinking 0.6s ease-in-out infinite;
        }
        
        /* Enhanced eye states for full body */
        .robot-eye-fullbody.listening {
            animation: eyePulse 2s ease-in-out infinite, eyeListening 1s ease-in-out infinite;
            background: radial-gradient(circle, #000 30%, #00ffff 35%, #0088ff 100%);
        }
        
        .robot-eye-fullbody.thinking {
            animation: eyeThinking 0.8s ease-in-out infinite;
            background: radial-gradient(circle, #000 30%, #8338ec 35%, #a370ff 100%);
        }
        
        .robot-eye-fullbody.speaking {
            animation: eyeSpeaking 0.3s ease-in-out infinite;
            background: radial-gradient(circle, #000 30%, #d870f0 35%, #ff88cc 100%);
        }
        
        /* Enhanced Animations */
        @keyframes headFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-5px) rotate(2deg); }
        }
        
        @keyframes torsoGlow {
            0% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.1); }
            100% { box-shadow: 0 0 40px rgba(0, 255, 255, 0.6), inset 0 0 30px rgba(0, 255, 255, 0.2); }
        }
        
        @keyframes chestLight {
            0%, 100% { opacity: 0.6; transform: translateX(-50%) scale(1); }
            50% { opacity: 1; transform: translateX(-50%) scale(1.2); }
        }
        
        @keyframes leftArmMove {
            0%, 100% { transform: rotate(-10deg); }
            25% { transform: rotate(15deg); }
            50% { transform: rotate(-5deg); }
            75% { transform: rotate(20deg); }
        }
        
        @keyframes rightArmMove {
            0%, 100% { transform: rotate(10deg); }
            30% { transform: rotate(-15deg); }
            60% { transform: rotate(25deg); }
            90% { transform: rotate(-10deg); }
        }
        
        @keyframes handGlow {
            0% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.8); }
            100% { box-shadow: 0 0 25px rgba(0, 255, 255, 1), 0 0 35px rgba(0, 255, 255, 0.6); }
        }
        
        @keyframes leftLegWalk {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(15deg); }
            75% { transform: rotate(-10deg); }
        }
        
        @keyframes rightLegWalk {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-15deg); }
            75% { transform: rotate(10deg); }
        }
        
        @keyframes activityFloat {
            0% { opacity: 0; transform: translateX(-50%) translateY(0px); }
            50% { opacity: 1; transform: translateX(-50%) translateY(-20px); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-40px); }
        }
        
        @keyframes robotWalkAround {
            0% { 
                left: -15%; 
                top: 60%; 
                transform: scale(0.4) rotate(0deg); 
            }
            25% { 
                left: 25%; 
                top: 20%; 
                transform: scale(0.5) rotate(90deg); 
            }
            50% { 
                left: 75%; 
                top: 70%; 
                transform: scale(0.6) rotate(180deg); 
            }
            75% { 
                left: 85%; 
                top: 30%; 
                transform: scale(0.4) rotate(270deg); 
            }
            100% { 
                left: 115%; 
                top: 50%; 
                transform: scale(0.3) rotate(360deg); 
            }
        }
        
        @keyframes galaxyRotation {
            0% { transform: translate(-10%, -10%) rotate(0deg); }
            100% { transform: translate(-10%, -10%) rotate(360deg); }
        }
        
        @keyframes starfieldSlow {
            0% { transform: translateY(0px) translateX(0px); }
            100% { transform: translateY(-600px) translateX(-200px); }
        }
        
        @keyframes starfieldMid {
            0% { transform: translateY(0px) translateX(0px); }
            100% { transform: translateY(-400px) translateX(-150px); }
        }
        
        @keyframes starfieldFast {
            0% { transform: translateY(0px) translateX(0px); }
            100% { transform: translateY(-300px) translateX(-100px); }
        }
        
        @keyframes starTwinkle {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        @keyframes alienDrift {
            0%, 100% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            25% { transform: translateY(-30px) translateX(20px) rotate(5deg); }
            50% { transform: translateY(-10px) translateX(-15px) rotate(-3deg); }
            75% { transform: translateY(-20px) translateX(10px) rotate(2deg); }
        }
        
        @keyframes cometTrail {
            0% { left: -100px; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { left: calc(100vw + 100px); opacity: 0; }
        }
        
        @keyframes planetRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes move-planet-1 {
            0% { transform: translate(-20vw, 120vh) scale(0.8); }
            100% { transform: translate(120vw, -20vh) scale(1.2); }
        }
        
        @keyframes move-planet-2 {
            0% { transform: translate(110vw, 80vh) scale(0.6); }
            100% { transform: translate(-30vw, 10vh) scale(0.9); }
        }
        
        @keyframes move-planet-3 {
            0% { transform: translate(50vw, 110vh) scale(0.5); }
            100% { transform: translate(30vw, -10vh) scale(0.5); }
        }
        
        @keyframes glow {
            0% { text-shadow: 0 0 40px rgba(0, 255, 255, 0.9); }
            100% { text-shadow: 0 0 80px rgba(0, 255, 255, 1), 0 0 120px rgba(255, 0, 255, 0.6); }
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes titleUnderline {
            0% { width: 100px; opacity: 0.5; }
            100% { width: 300px; opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        @keyframes eyePulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        
        @keyframes pupilMove {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(3px, -2px); }
            50% { transform: translate(-2px, 2px); }
            75% { transform: translate(2px, 3px); }
        }
        
        @keyframes eyeListening {
            0%, 100% { box-shadow: 0 0 20px #00ffff; }
            50% { box-shadow: 0 0 30px #00aaff, 0 0 40px rgba(0, 170, 255, 0.5); }
        }
        
        @keyframes eyeThinking {
            0%, 100% { box-shadow: 0 0 20px #8338ec; }
            50% { box-shadow: 0 0 35px #a370ff, 0 0 50px rgba(163, 112, 255, 0.6); }
        }
        
        @keyframes eyeSpeaking {
            0%, 100% { box-shadow: 0 0 20px #d870f0; }
            50% { box-shadow: 0 0 40px #ff88cc, 0 0 60px rgba(255, 136, 204, 0.7); }
        }
        
        @keyframes earListening {
            0%, 100% { 
                transform: rotate(-15deg) scale(1); 
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); 
            }
            50% { 
                transform: rotate(-15deg) scale(1.2); 
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.8); 
            }
        }
        
        @keyframes mouthListening {
            0%, 100% { transform: scaleY(0.2); }
            50% { transform: scaleY(0.4); }
        }
        
        @keyframes mouthUserSpeaking {
            0%, 100% { transform: scaleY(0.3) scaleX(0.9); }
            50% { transform: scaleY(0.8) scaleX(1.1); }
        }
        
        @keyframes mouthAISpeaking {
            0%, 100% { transform: scaleY(0.4) scaleX(0.8); }
            25% { transform: scaleY(0.9) scaleX(1.2); }
            50% { transform: scaleY(0.6) scaleX(1.0); }
            75% { transform: scaleY(1.0) scaleX(1.1); }
        }
        
        @keyframes mouthThinking {
            0%, 100% { transform: scaleY(0.2) scaleX(0.9); }
            50% { transform: scaleY(0.5) scaleX(1.0); }
        }
        
        @keyframes ringPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 0.6; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.1); 
                opacity: 1; 
            }
        }
        
        @keyframes ringThinking {
            0%, 100% { 
                transform: translate(-50%, -50%) rotate(0deg) scale(1); 
            }
            50% { 
                transform: translate(-50%, -50%) rotate(180deg) scale(1.05); 
            }
        }
        
        @keyframes ringSpeaking {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                border-width: 2px; 
            }
            25% { 
                transform: translate(-50%, -50%) scale(1.08); 
                border-width: 4px; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.03); 
                border-width: 3px; 
            }
            75% { 
                transform: translate(-50%, -50%) scale(1.12); 
                border-width: 5px; 
            }
        }
        
        @keyframes waveScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        @keyframes borderGlow {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        @keyframes holoPulse {
            0%, 100% { 
                opacity: 0.8; 
                box-shadow: 0 0 60px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.1);
                transform: scale(1);
            }
            50% { 
                opacity: 1; 
                box-shadow: 0 0 80px rgba(0, 255, 255, 0.8), inset 0 0 40px rgba(0, 255, 255, 0.2);
                transform: scale(1.05);
            }
        }
        
        /* Advanced Wave Animations */
        .wave-active.listening {
            background: #00ffff;
            animation: listeningWave 0.5s infinite;
        }
        
        .wave-active.user-speaking {
            background: #00aaff;
            animation: userWave 0.2s infinite ease-in-out;
            height: 12px;
        }
        
        .wave-active.ai-speaking {
            background: #d870f0;
            animation: aiWave 1.5s infinite ease-in-out;
            height: 15px;
        }
        
        .wave-active.thinking {
            background: #8338ec;
            animation: thinkingWave 0.8s infinite;
            height: 8px;
        }
        
        @keyframes listeningWave {
            0%, 100% { 
                clip-path: polygon(0 50%, 5% 45%, 10% 55%, 15% 40%, 20% 60%, 25% 35%, 30% 65%, 35% 45%, 40% 55%, 45% 40%, 50% 60%, 55% 35%, 60% 65%, 65% 45%, 70% 55%, 75% 40%, 80% 60%, 85% 45%, 90% 55%, 95% 50%, 100% 50%); 
            }
            50% { 
                clip-path: polygon(0 50%, 5% 55%, 10% 45%, 15% 60%, 20% 40%, 25% 65%, 30% 35%, 35% 55%, 40% 45%, 45% 60%, 50% 40%, 55% 65%, 60% 35%, 65% 55%, 70% 45%, 75% 60%, 80% 40%, 85% 55%, 90% 45%, 95% 50%, 100% 50%); 
            }
        }
        
        @keyframes userWave {
            0% { 
                clip-path: polygon(0 45%, 10% 55%, 20% 35%, 30% 65%, 40% 40%, 50% 60%, 60% 20%, 70% 80%, 80% 40%, 90% 55%, 100% 45%); 
            }
            50% { 
                clip-path: polygon(0 55%, 10% 45%, 20% 75%, 30% 25%, 40% 60%, 50% 40%, 60% 80%, 70% 20%, 80% 60%, 90% 45%, 100% 55%); 
            }
            100% { 
                clip-path: polygon(0 45%, 10% 55%, 20% 35%, 30% 65%, 40% 40%, 50% 60%, 60% 20%, 70% 80%, 80% 40%, 90% 55%, 100% 45%); 
            }
        }
        
        @keyframes aiWave {
            0% { 
                clip-path: polygon(0% 50%, 15% 25%, 30% 50%, 50% 75%, 70% 50%, 85% 25%, 100% 50%); 
            }
            50% { 
                clip-path: polygon(0% 50%, 15% 75%, 30% 50%, 50% 25%, 70% 50%, 85% 75%, 100% 50%); 
            }
            100% { 
                clip-path: polygon(0% 50%, 15% 25%, 30% 50%, 50% 75%, 70% 50%, 85% 25%, 100% 50%); 
            }
        }
        
        @keyframes thinkingWave {
            0%, 100% { 
                clip-path: polygon(0 50%, 10% 45%, 20% 55%, 30% 40%, 40% 60%, 50% 35%, 60% 65%, 70% 30%, 80% 70%, 90% 45%, 100% 55%); 
            }
            33% { 
                clip-path: polygon(0 45%, 10% 55%, 20% 35%, 30% 65%, 40% 30%, 50% 70%, 60% 25%, 70% 75%, 80% 40%, 90% 60%, 100% 50%); 
            }
            66% { 
                clip-path: polygon(0 55%, 10% 35%, 20% 65%, 30% 30%, 40% 70%, 50% 45%, 60% 55%, 70% 40%, 80% 60%, 90% 35%, 100% 65%); 
            }
        }

        /* Mobile Responsive - Updated for Full Body Robot */
        @media (max-width: 768px) {
            .title { 
                font-size: 3.5em; 
                letter-spacing: 8px; 
            }
            
            .subtitle {
                font-size: 1.2em;
                letter-spacing: 4px;
            }
            
            .wave-container { 
                width: 90%; 
                height: 100px;
            }
            
            .robot-body-container { 
                width: 250px; 
                height: 380px; 
            }
            
            .robot-head {
                width: 100px;
                height: 100px;
            }
            
            .robot-torso {
                width: 80px;
                height: 120px;
            }
            
            .robot-arms {
                width: 160px;
                top: 120px;
            }
            
            .robot-arm {
                height: 60px;
            }
            
            .robot-leg {
                height: 100px;
            }
            
            .voice-status-ring {
                width: 280px;
                height: 280px;
            }
        }
        
        @media (max-width: 480px) {
            .title { 
                font-size: 2.5em; 
                letter-spacing: 4px; 
            }
            
            .robot-body-container { 
                width: 200px; 
                height: 320px; 
            }
            
            .robot-head {
                width: 80px;
                height: 80px;
            }
            
            .robot-torso {
                width: 65px;
                height: 100px;
            }
            
            .robot-arms {
                width: 140px;
                top: 100px;
            }
            
            .robot-arm {
                height: 50px;
                width: 12px;
            }
            
            .robot-leg {
                height: 80px;
                width: 16px;
            }
            
            .voice-status-ring {
                width: 240px;
                height: 240px;
            }
        }
        
        /* Parallax Effect Variables */
        :root {
            --mouse-x: 50%;
            --mouse-y: 50%;
        }
    </style>
</head>
<body>
    <div class="cosmic-cursor" id="cosmicCursor"></div>
    
    <div id="start-overlay">
        <button id="start-button">Initialize NEXUS Protocol</button>
    </div>

    <!-- Enhanced Background Layers -->
    <div class="space-bg" id="spaceBg"></div>
    
    <div class="stars-layer">
        <div class="stars-distant" id="starsDistant"></div>
        <div class="stars-mid" id="starsMid"></div>
        <div class="stars-near" id="starsNear"></div>
    </div>
    
    <!-- Alien Silhouettes -->
    <div class="alien-silhouettes">
        <div class="alien-ship alien-ship-1"></div>
        <div class="alien-ship alien-ship-2"></div>
        <div class="alien-ship alien-ship-3"></div>
    </div>
    
    <!-- Comets -->
    <div class="comet comet-1"></div>
    <div class="comet comet-2"></div>
    
    <!-- Enhanced Planets -->
    <div class="planets-container">
        <div class="planet planet-1"></div>
        <div class="planet planet-2"></div>
        <div class="planet planet-3"></div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="title">NEXUS 3000</div>
        <div class="subtitle">COSMIC AGI CONSCIOUSNESS</div>

        <!-- Enhanced Full Body Robot -->
        <div class="robot-body-container">
            <div class="voice-status-ring" id="voiceStatusRing"></div>
            <div class="constellation-bg" id="constellationBg"></div>
            
            <!-- Robot Head -->
            <div class="robot-head">
                <!-- Robot Ears -->
                <div class="robot-ears-fullbody">
                    <div class="robot-ear-fullbody left" id="leftEarFull"></div>
                    <div class="robot-ear-fullbody right" id="rightEarFull"></div>
                </div>
                
                <!-- Robot Eyes -->
                <div class="robot-eyes-fullbody">
                    <div class="robot-eye-fullbody" id="leftEyeFull"></div>
                    <div class="robot-eye-fullbody" id="rightEyeFull"></div>
                </div>
                
                <!-- Robot Mouth -->
                <div class="robot-mouth-fullbody">
                    <div class="mouth-indicator-fullbody" id="mouthIndicatorFull"></div>
                </div>
            </div>
            
            <!-- Robot Arms -->
            <div class="robot-arms">
                <div class="robot-arm left">
                    <div class="robot-hand"></div>
                </div>
                <div class="robot-arm right">
                    <div class="robot-hand"></div>
                </div>
            </div>
            
            <!-- Robot Body -->
            <div class="robot-torso"></div>
            
            <!-- Robot Legs -->
            <div class="robot-legs">
                <div class="robot-leg left">
                    <div class="robot-foot"></div>
                </div>
                <div class="robot-leg right">
                    <div class="robot-foot"></div>
                </div>
            </div>
            
            <!-- Activity Indicator -->
            <div class="robot-activity" id="robotActivity">🔧</div>
        </div>
        
        <!-- Background Walking Robots -->
        <div class="robot-movement-container">
            <div class="floating-robot" id="floatingRobot1">
                <div class="robot-body-container" style="transform: scale(0.5);">
                    <div class="robot-head">
                        <div class="robot-eyes-fullbody">
                            <div class="robot-eye-fullbody"></div>
                            <div class="robot-eye-fullbody"></div>
                        </div>
                    </div>
                    <div class="robot-torso"></div>
                    <div class="robot-legs">
                        <div class="robot-leg left"><div class="robot-foot"></div></div>
                        <div class="robot-leg right"><div class="robot-foot"></div></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Enhanced Wave Container -->
        <div class="wave-container">
            <div class="wave-line"></div>
            <div class="wave-active" id="waveActive"></div>
        </div>
    </div>

    <!-- Enhanced Status Indicator -->
    <div class="status-indicator" id="statusIndicator">
        Initializing...
    </div>

    <video id="videoElement" autoplay muted playsinline style="position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px;"></video>
    <audio id="silent-audio" muted playsinline></audio>

    <script>
        // Enhanced Variables and State Management
        let isListening = false;
        let isSpeaking = false;
        let canListen = true;
        let cameraActive = false;
        let hasAttemptedCameraInit = false;
        let recognition = null;
        let sessionId = Math.random().toString(36).substr(2, 9);
        let hasGreeted = false;
        let listeningRestartTimeout = null;
        let recognitionTimeout = null;
        let mouseX = 0;
        let mouseY = 0;

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isAndroid = /Android/.test(navigator.userAgent);
        let silenceCheckTimer = null;
        let lastResultTime = 0;
        let hasRecognitionStarted = false;

        // Enhanced Robot Personality and Autonomous Behavior - MOVED TO GLOBAL SCOPE
        const robotPersonality = {
            physicalActivities: [
                { emoji: '💪', name: 'doing pushups', duration: 8000, animation: 'pushups', eyeState: 'focused' },
                { emoji: '🏃', name: 'jogging in place', duration: 6000, animation: 'jogging', eyeState: 'energetic' },
                { emoji: '🧘', name: 'meditating', duration: 10000, animation: 'meditation', eyeState: 'calm' },
                { emoji: '🤸', name: 'stretching', duration: 5000, animation: 'stretching', eyeState: 'focused' },
                { emoji: '🏋️', name: 'lifting weights', duration: 7000, animation: 'lifting', eyeState: 'determined' },
                { emoji: '🕺', name: 'dancing', duration: 6000, animation: 'dancing', eyeState: 'happy' },
                { emoji: '🤾', name: 'jumping jacks', duration: 5000, animation: 'jumping', eyeState: 'energetic' }
            ],
            mentalActivities: [
                { emoji: '📺', name: 'watching TV', duration: 12000, animation: 'watching', eyeState: 'focused' },
                { emoji: '📚', name: 'reading quantum physics', duration: 8000, animation: 'reading', eyeState: 'thinking' },
                { emoji: '🎮', name: 'playing games', duration: 7000, animation: 'gaming', eyeState: 'focused' },
                { emoji: '🎨', name: 'creating art', duration: 9000, animation: 'creating', eyeState: 'inspired' },
                { emoji: '🧩', name: 'solving puzzles', duration: 6000, animation: 'puzzling', eyeState: 'thinking' },
                { emoji: '🎵', name: 'composing music', duration: 8000, animation: 'composing', eyeState: 'creative' },
                { emoji: '📝', name: 'writing poetry', duration: 7000, animation: 'writing', eyeState: 'thoughtful' }
            ],
            chores: [
                { emoji: '🧹', name: 'sweeping floor', duration: 6000, animation: 'sweeping', eyeState: 'focused' },
                { emoji: '🧽', name: 'cleaning surfaces', duration: 5000, animation: 'cleaning', eyeState: 'methodical' },
                { emoji: '📦', name: 'organizing files', duration: 7000, animation: 'organizing', eyeState: 'systematic' },
                { emoji: '🔧', name: 'fixing circuits', duration: 8000, animation: 'repairing', eyeState: 'concentrated' },
                { emoji: '🌱', name: 'watering plants', duration: 4000, animation: 'watering', eyeState: 'gentle' },
                { emoji: '🍳', name: 'cooking', duration: 9000, animation: 'cooking', eyeState: 'focused' }
            ],
            exploratoryActivities: [
                { emoji: '🔍', name: 'investigating sounds', duration: 5000, animation: 'investigating', eyeState: 'curious' },
                { emoji: '🌌', name: 'stargazing', duration: 10000, animation: 'stargazing', eyeState: 'wondering' },
                { emoji: '📡', name: 'scanning frequencies', duration: 6000, animation: 'scanning', eyeState: 'searching' },
                { emoji: '🧪', name: 'experimenting', duration: 8000, animation: 'experimenting', eyeState: 'scientific' },
                { emoji: '🎯', name: 'target practice', duration: 6000, animation: 'aiming', eyeState: 'precise' }
            ],
            socialActivities: [
                { emoji: '📞', name: 'calling friends', duration: 8000, animation: 'calling', eyeState: 'social' },
                { emoji: '💬', name: 'chatting online', duration: 7000, animation: 'chatting', eyeState: 'engaged' },
                { emoji: '📸', name: 'taking selfies', duration: 4000, animation: 'selfie', eyeState: 'playful' },
                { emoji: '🎤', name: 'practicing speeches', duration: 6000, animation: 'speaking', eyeState: 'confident' }
            ],
            aiGeneratedActivities: [], // Will be populated by OpenAI
            currentActivity: null,
            moods: ['curious', 'contemplative', 'energetic', 'focused', 'dreamy', 'playful', 'determined', 'creative'],
            currentMood: 'curious',
            moodTimer: null,
            activityTimer: null,
            autonomousTimer: null,
            aiActivityTimer: null,
            isIdle: true,
            lastInteraction: Date.now(),
            idleStartTime: null,
            personality: 'friendly', // Can be: friendly, serious, playful, curious, etc.
            energy: 100, // 0-100, affects activity choices
            interests: ['technology', 'space', 'music', 'learning', 'helping'], // Grows over time
            lastAIActivityFetch: 0
        };

        // Enhanced DOM Elements for Full Body Robot
        const waveActive = document.getElementById('waveActive');
        const statusIndicator = document.getElementById('statusIndicator');
        const startOverlay = document.getElementById('start-overlay');
        const silentAudio = document.getElementById('silent-audio');
        const leftEyeFull = document.getElementById('leftEyeFull');
        const rightEyeFull = document.getElementById('rightEyeFull');
        const leftEarFull = document.getElementById('leftEarFull');
        const rightEarFull = document.getElementById('rightEarFull');
        const mouthIndicatorFull = document.getElementById('mouthIndicatorFull');
        const robotActivity = document.getElementById('robotActivity');
        const voiceStatusRing = document.getElementById('voiceStatusRing');
        const cosmicCursor = document.getElementById('cosmicCursor');
        const spaceBg = document.getElementById('spaceBg');
        const starsDistant = document.getElementById('starsDistant');
        const starsMid = document.getElementById('starsMid');
        const starsNear = document.getElementById('starsNear');

        // Simple, bulletproof autonomous system
        let autonomousInterval = null;
        let moodInterval = null;
        let activityIndex = 0;

        // Simple activity list that always works
        const simpleActivities = [
            { emoji: '💪', name: 'doing pushups', duration: 6000 },
            { emoji: '📺', name: 'watching TV', duration: 8000 },
            { emoji: '🧹', name: 'cleaning', duration: 5000 },
            { emoji: '🎵', name: 'humming', duration: 4000 },
            { emoji: '🔧', name: 'tinkering', duration: 7000 },
            { emoji: '🌌', name: 'stargazing', duration: 9000 },
            { emoji: '🕺', name: 'dancing', duration: 6000 },
            { emoji: '🍳', name: 'cooking', duration: 8000 }
        ];

        function startSimpleAutonomy() {
            console.log("🚀 Starting SIMPLE autonomous system...");
            
            // Clear any existing intervals
            if (autonomousInterval) clearInterval(autonomousInterval);
            if (moodInterval) clearInterval(moodInterval);
            
            // Start autonomous activities every 10 seconds
            autonomousInterval = setInterval(() => {
                if (!isSpeaking) {
                    doSimpleActivity();
                }
            }, 10000);
            
            // Start mood changes every 30 seconds
            moodInterval = setInterval(() => {
                if (!isSpeaking) {
                    doMoodChange();
                }
            }, 30000);
            
            // Force first activity after 5 seconds
            setTimeout(() => {
                console.log("🧪 FORCING first activity...");
                doSimpleActivity();
            }, 5000);
        }

        function doSimpleActivity() {
            try {
                const activity = simpleActivities[activityIndex];
                activityIndex = (activityIndex + 1) % simpleActivities.length;
                
                console.log(`🤖 NEXUS is ${activity.name}!`);
                
                // Show the activity emoji
                const activityElement = document.getElementById('robotActivity');
                if (activityElement) {
                    activityElement.textContent = activity.emoji;
                    activityElement.style.opacity = '1';
                    activityElement.style.animation = 'activityFloat 3s ease-in-out infinite';
                }
                
                // Do the animation
                doSimpleAnimation(activity);
                
                // Return to normal after duration
                setTimeout(() => {
                    if (activityElement) {
                        activityElement.style.opacity = '0.7';
                    }
                }, activity.duration);
                
            } catch (error) {
                console.error("❌ Error in doSimpleActivity:", error);
            }
        }

        function doSimpleAnimation(activity) {
            try {
                const container = document.querySelector('.robot-body-container');
                const leftEye = document.getElementById('leftEyeFull');
                const rightEye = document.getElementById('rightEyeFull');
                const torso = document.querySelector('.robot-torso');
                const arms = document.querySelectorAll('.robot-arm');
                
                if (!container) {
                    console.log("❌ Could not find robot container");
                    return;
                }
                
                console.log(`🎬 Animating: ${activity.name}`);
                
                switch(activity.name) {
                    case 'doing pushups':
                        let pushupCount = 0;
                        const pushupTimer = setInterval(() => {
                            if (torso) {
                                torso.style.transform = pushupCount % 2 === 0 ? 'translateY(8px)' : 'translateY(0px)';
                            }
                            pushupCount++;
                            if (pushupCount >= 8) {
                                clearInterval(pushupTimer);
                                if (torso) torso.style.transform = '';
                            }
                        }, 600);
                        break;
                        
                    case 'dancing':
                        let danceCount = 0;
                        const danceTimer = setInterval(() => {
                            container.style.transform = `rotate(${Math.sin(danceCount) * 5}deg)`;
                            if (arms.length >= 2) {
                                arms[0].style.transform = `rotate(${Math.sin(danceCount) * 30}deg)`;
                                arms[1].style.transform = `rotate(${Math.cos(danceCount) * 30}deg)`;
                            }
                            danceCount += 0.3;
                            if (danceCount >= 10) {
                                clearInterval(danceTimer);
                                container.style.transform = '';
                                arms.forEach(arm => arm.style.transform = '');
                            }
                        }, 200);
                        break;
                        
                    case 'watching TV':
                        if (leftEye && rightEye) {
                            let direction = 1;
                            const watchTimer = setInterval(() => {
                                leftEye.style.transform = `translateX(${direction * 3}px)`;
                                rightEye.style.transform = `translateX(${direction * 3}px)`;
                                direction *= -1;
                            }, 2000);
                            setTimeout(() => {
                                clearInterval(watchTimer);
                                leftEye.style.transform = '';
                                rightEye.style.transform = '';
                            }, 6000);
                        }
                        break;
                        
                    default:
                        // Simple head bob for other activities
                        let bobCount = 0;
                        const bobTimer = setInterval(() => {
                            container.style.transform = `translateY(${Math.sin(bobCount) * 2}px)`;
                            bobCount += 0.2;
                            if (bobCount >= 4) {
                                clearInterval(bobTimer);
                                container.style.transform = '';
                            }
                        }, 200);
                }
                
            } catch (error) {
                console.error("❌ Error in animation:", error);
            }
        }

        function doMoodChange() {
            const moods = ['curious', 'energetic', 'contemplative', 'playful'];
            const mood = moods[Math.floor(Math.random() * moods.length)];
            console.log(`🎭 NEXUS mood: ${mood}`);
            
            const head = document.querySelector('.robot-head');
            if (head) {
                const angle = (Math.random() - 0.5) * 10;
                head.style.transform = `rotate(${angle}deg)`;
                setTimeout(() => {
                    head.style.transform = '';
                }, 2000);
            }
        }
            const now = Date.now();
            // Only fetch new activities every 5 minutes to avoid spam
            if (now - robotPersonality.lastAIActivityFetch < 300000) return;
            
            robotPersonality.lastAIActivityFetch = now;
            
            try {
                console.log("🧠 NEXUS requesting new activity ideas from AI consciousness...");
                
                const prompt = `Generate 5 creative, fun activities that a friendly robot could do when alone. Consider the robot's current mood: ${robotPersonality.currentMood}, energy level: ${robotPersonality.energy}, and interests: ${robotPersonality.interests.join(', ')}. 

                Return ONLY a JSON array like this:
                [
                    {"emoji": "🎭", "name": "practicing magic tricks", "duration": 6000, "type": "entertainment"},
                    {"emoji": "🔬", "name": "analyzing dust particles", "duration": 8000, "type": "scientific"}
                ]
                
                Make them unique, creative, and robot-appropriate. No violence or inappropriate content.`;

                const response = await getAIResponse(prompt);
                
                // Try to parse the AI response as JSON
                try {
                    const newActivities = JSON.parse(response);
                    if (Array.isArray(newActivities)) {
                        newActivities.forEach(activity => {
                            activity.animation = 'ai_generated';
                            activity.eyeState = 'creative';
                            activity.source = 'ai';
                        });
                        
                        robotPersonality.aiGeneratedActivities = 
                            robotPersonality.aiGeneratedActivities.concat(newActivities).slice(-20); // Keep last 20
                        
                        console.log(`🎯 NEXUS learned ${newActivities.length} new activities:`, newActivities.map(a => a.name));
                    }
                } catch (parseError) {
                    console.log("AI response wasn't valid JSON, but that's okay");
                }
            } catch (error) {
                console.log("Couldn't get new activities from AI, using built-in ones");
            }
        }

        // Enhanced activity selection with AI integration
        function getAllActivities() {
            return [
                ...robotPersonality.physicalActivities,
                ...robotPersonality.mentalActivities,
                ...robotPersonality.chores,
                ...robotPersonality.exploratoryActivities,
                ...robotPersonality.socialActivities,
                ...robotPersonality.aiGeneratedActivities
            ];
        }

        // Intelligent activity selection based on mood, energy, and time
        function selectSmartActivity() {
            const allActivities = getAllActivities();
            const mood = robotPersonality.currentMood;
            const energy = robotPersonality.energy;
            
            let preferredActivities = allActivities;
            
            // Filter by energy level
            if (energy > 70) {
                preferredActivities = [...robotPersonality.physicalActivities, ...robotPersonality.exploratoryActivities];
            } else if (energy < 30) {
                preferredActivities = [...robotPersonality.mentalActivities];
            }
            
            // Filter by mood
            switch(mood) {
                case 'energetic':
                    preferredActivities = preferredActivities.filter(a => 
                        robotPersonality.physicalActivities.includes(a) || a.name.includes('dancing'));
                    break;
                case 'contemplative':
                    preferredActivities = [...robotPersonality.mentalActivities, ...robotPersonality.exploratoryActivities];
                    break;
                case 'playful':
                    preferredActivities = [...robotPersonality.socialActivities, ...robotPersonality.aiGeneratedActivities];
                    break;
            }
            
            if (preferredActivities.length === 0) preferredActivities = allActivities;
            
            return preferredActivities[Math.floor(Math.random() * preferredActivities.length)];
        }

        // Start comprehensive robot autonomous behavior
        function startRobotActivities() {
            if (robotPersonality.activityTimer) clearInterval(robotPersonality.activityTimer);
            if (robotPersonality.moodTimer) clearInterval(robotPersonality.moodTimer);
            if (robotPersonality.autonomousTimer) clearInterval(robotPersonality.autonomousTimer);
            if (robotPersonality.aiActivityTimer) clearInterval(robotPersonality.aiActivityTimer);
            
            // Fetch new AI activities periodically
            robotPersonality.aiActivityTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    fetchNewActivities();
                }
            }, 300000); // Every 5 minutes
            
            // Initial AI activity fetch
            setTimeout(() => fetchNewActivities(), 2000);
            
            // Mood changes every 45-90 seconds
            robotPersonality.moodTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    changeMood();
                }
            }, Math.random() * 45000 + 45000);
            
            // Activities every 8-15 seconds when idle
            robotPersonality.activityTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    performIdleActivity();
                }
            }, Math.random() * 7000 + 8000);
            
            // Autonomous behaviors (blinking, looking around, etc.)
            robotPersonality.autonomousTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    performAutonomousBehavior();
                }
            }, Math.random() * 3000 + 2000);
        }

        function changeMood() {
            const newMood = robotPersonality.moods[Math.floor(Math.random() * robotPersonality.moods.length)];
            robotPersonality.currentMood = newMood;
            
            // Adjust energy based on mood
            switch(newMood) {
                case 'energetic':
                    robotPersonality.energy = Math.min(100, robotPersonality.energy + 10);
                    break;
                case 'contemplative':
                    robotPersonality.energy = Math.max(20, robotPersonality.energy - 5);
                    break;
                case 'playful':
                    robotPersonality.energy = Math.min(90, robotPersonality.energy + 5);
                    break;
            }
            
            console.log(`🤖 NEXUS mood shift: ${newMood} (Energy: ${robotPersonality.energy})`);
            
            // Visual mood changes
            const head = document.querySelector('.robot-head');
            switch(newMood) {
                case 'curious':
                    head.style.transform = 'rotate(5deg)';
                    break;
                case 'contemplative':
                    head.style.transform = 'rotate(-3deg)';
                    break;
                case 'energetic':
                    head.style.transform = 'rotate(0deg) scale(1.05)';
                    break;
                case 'playful':
                    head.style.transform = 'rotate(8deg)';
                    break;
                case 'determined':
                    head.style.transform = 'rotate(0deg) scaleY(1.1)';
                    break;
                case 'creative':
                    head.style.transform = 'rotate(-5deg) scale(1.02)';
                    break;
            }
            
            setTimeout(() => {
                head.style.transform = '';
            }, 3000);
        }

        function performIdleActivity() {
            const activity = selectSmartActivity();
            robotPersonality.currentActivity = activity;
            
            console.log(`🤖 NEXUS is ${activity.name}... (${activity.source || 'built-in'})`);
            
            // Show activity
            robotActivity.textContent = activity.emoji;
            robotActivity.style.opacity = '1';
            robotActivity.style.animation = 'none';
            setTimeout(() => {
                robotActivity.style.animation = 'activityFloat 3s ease-in-out infinite';
            }, 100);
            
            // Change eye state based on activity (but don't interfere with listening state completely)
            if (!isListening || Date.now() - robotPersonality.lastInteraction > 20000) {
                updateRobotState(activity.eyeState || 'thinking');
            }
            
            // Always perform the activity animation regardless of listening state
            performActivityAnimation(activity);
            
            // Adjust energy after activity
            adjustEnergyAfterActivity(activity);
            
            // Return to appropriate state after activity
            setTimeout(() => {
                if (!isSpeaking) {
                    if (Date.now() - robotPersonality.lastInteraction > 30000) {
                        // Been quiet for 30+ seconds, stay in autonomous mode
                        updateRobotState('');
                        updateStatusIndicator('🤖 Autonomous mode', '', true);
                        setTimeout(() => updateStatusIndicator('', '', false), 2000);
                    } else if (canListen) {
                        // Return to listening if appropriate
                        updateRobotState('listening');
                        updateStatusIndicator('🎤 Listening...', 'listening', true);
                    }
                    robotActivity.style.opacity = '0.7';
                    robotPersonality.currentActivity = null;
                }
            }, activity.duration);
        }

        // Monitor idle state continuously
        setInterval(updateIdleState, 2000);
        
        // Also add a backup autonomous trigger
        setInterval(() => {
            const timeSinceInteraction = Date.now() - robotPersonality.lastInteraction;
            if (timeSinceInteraction > 25000 && !robotPersonality.currentActivity) {
                console.log("🤖 Backup autonomous trigger - forcing activity");
                performIdleActivity();
            }
        }, 10000); // Check every 10 seconds

        function performActivityAnimation(activity) {
            switch(activity.animation) {
                case 'pushups':
                    simulatePushups();
                    break;
                case 'jogging':
                    simulateJogging();
                    break;
                case 'dancing':
                    simulateDancing();
                    break;
                case 'watching':
                    simulateWatchingTV();
                    break;
                case 'reading':
                    simulateReading();
                    break;
                case 'cooking':
                    simulateCooking();
                    break;
                case 'sweeping':
                    simulateSweeping();
                    break;
                case 'stargazing':
                    simulateStargazing();
                    break;
                case 'ai_generated':
                    simulateAIActivity();
                    break;
                default:
                    simulateGenericActivity();
            }
        }

        function simulatePushups() {
            const torso = document.querySelector('.robot-torso');
            let count = 0;
            const pushupInterval = setInterval(() => {
                torso.style.transform = count % 2 === 0 ? 'translateY(8px)' : 'translateY(0px)';
                count++;
                if (count >= 10) {
                    clearInterval(pushupInterval);
                    torso.style.transform = '';
                }
            }, 600);
        }

        function simulateJogging() {
            const legs = document.querySelectorAll('.robot-leg');
            const container = document.querySelector('.robot-body-container');
            let step = 0;
            const joggingInterval = setInterval(() => {
                container.style.transform = `translateY(${Math.sin(step) * 3}px)`;
                legs[0].style.transform = `rotate(${Math.sin(step) * 15}deg)`;
                legs[1].style.transform = `rotate(${Math.sin(step + Math.PI) * 15}deg)`;
                step += 0.3;
                if (step >= Math.PI * 6) {
                    clearInterval(joggingInterval);
                    container.style.transform = '';
                    legs.forEach(leg => leg.style.transform = '');
                }
            }, 100);
        }

        function simulateDancing() {
            const container = document.querySelector('.robot-body-container');
            const arms = document.querySelectorAll('.robot-arm');
            let beat = 0;
            const danceInterval = setInterval(() => {
                container.style.transform = `rotate(${Math.sin(beat) * 5}deg) translateY(${Math.cos(beat) * 2}px)`;
                arms[0].style.transform = `rotate(${Math.sin(beat) * 30 - 10}deg)`;
                arms[1].style.transform = `rotate(${Math.cos(beat) * 30 + 10}deg)`;
                beat += 0.2;
                if (beat >= Math.PI * 8) {
                    clearInterval(danceInterval);
                    container.style.transform = '';
                    arms.forEach(arm => arm.style.transform = '');
                }
            }, 150);
        }

        function simulateWatchingTV() {
            // Simulate watching TV - eyes move left and right following action
            let direction = 1;
            const watchInterval = setInterval(() => {
                leftEyeFull.style.transform = `translateX(${direction * 3}px)`;
                rightEyeFull.style.transform = `translateX(${direction * 3}px)`;
                direction *= -1;
            }, 2000);
            
            setTimeout(() => {
                clearInterval(watchInterval);
                leftEyeFull.style.transform = '';
                rightEyeFull.style.transform = '';
            }, 10000);
        }

        function simulateReading() {
            // Eyes move as if reading text
            let line = 0;
            const readInterval = setInterval(() => {
                leftEyeFull.style.transform = `translateX(${(line % 2) * 4 - 2}px) translateY(${Math.floor(line/2)}px)`;
                rightEyeFull.style.transform = `translateX(${(line % 2) * 4 - 2}px) translateY(${Math.floor(line/2)}px)`;
                line++;
                if (line >= 8) line = 0;
            }, 1000);
            
            setTimeout(() => {
                clearInterval(readInterval);
                leftEyeFull.style.transform = '';
                rightEyeFull.style.transform = '';
            }, 8000);
        }

        function simulateCooking() {
            const arms = document.querySelectorAll('.robot-arm');
            let stir = 0;
            const cookInterval = setInterval(() => {
                arms[0].style.transform = `rotate(${Math.sin(stir) * 20}deg)`;
                arms[1].style.transform = `rotate(${Math.cos(stir) * 15 + 10}deg)`;
                stir += 0.3;
            }, 200);
            
            setTimeout(() => {
                clearInterval(cookInterval);
                arms.forEach(arm => arm.style.transform = '');
            }, 8000);
        }

        function simulateSweeping() {
            const rightArm = document.querySelector('.robot-arm.right');
            let sweep = 0;
            const sweepInterval = setInterval(() => {
                rightArm.style.transform = `rotate(${Math.sin(sweep) * 40 + 20}deg)`;
                sweep += 0.2;
            }, 150);
            
            setTimeout(() => {
                clearInterval(sweepInterval);
                rightArm.style.transform = '';
            }, 6000);
        }

        function simulateAIActivity() {
            // Special animation for AI-generated activities
            const container = document.querySelector('.robot-body-container');
            let pulse = 0;
            const aiInterval = setInterval(() => {
                container.style.filter = `hue-rotate(${pulse * 10}deg) brightness(${1 + Math.sin(pulse) * 0.1})`;
                pulse += 0.1;
            }, 100);
            
            setTimeout(() => {
                clearInterval(aiInterval);
                container.style.filter = '';
            }, 5000);
        }

        function adjustEnergyAfterActivity(activity) {
            if (robotPersonality.physicalActivities.includes(activity)) {
                robotPersonality.energy = Math.max(10, robotPersonality.energy - 5); // Physical activities drain energy
            } else if (robotPersonality.mentalActivities.includes(activity)) {
                robotPersonality.energy = Math.max(20, robotPersonality.energy - 2); // Mental activities drain less
            } else if (activity.name.includes('resting') || activity.name.includes('meditation')) {
                robotPersonality.energy = Math.min(100, robotPersonality.energy + 10); // Rest restores energy
            }
        }

        // Start comprehensive robot autonomous behavior
        function startRobotActivities() {
            if (robotPersonality.activityTimer) clearInterval(robotPersonality.activityTimer);
            if (robotPersonality.moodTimer) clearInterval(robotPersonality.moodTimer);
            if (robotPersonality.autonomousTimer) clearInterval(robotPersonality.autonomousTimer);
            
            // Mood changes every 30-60 seconds
            robotPersonality.moodTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    changeMood();
                }
            }, Math.random() * 30000 + 30000);
            
            // Activities every 5-12 seconds when idle
            robotPersonality.activityTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    performIdleActivity();
                }
            }, Math.random() * 7000 + 5000);
            
            // Autonomous behaviors (blinking, looking around, etc.)
            robotPersonality.autonomousTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    performAutonomousBehavior();
                }
            }, Math.random() * 3000 + 2000);
        }

        function changeMood() {
            const newMood = robotPersonality.moods[Math.floor(Math.random() * robotPersonality.moods.length)];
            robotPersonality.currentMood = newMood;
            
            console.log(`🤖 NEXUS mood shift: ${newMood}`);
            
            // Visual mood changes
            const head = document.querySelector('.robot-head');
            switch(newMood) {
                case 'curious':
                    head.style.transform = 'rotate(5deg)';
                    break;
                case 'contemplative':
                    head.style.transform = 'rotate(-3deg)';
                    break;
                case 'energetic':
                    head.style.transform = 'rotate(0deg) scale(1.05)';
                    break;
                case 'focused':
                    head.style.transform = 'rotate(0deg)';
                    break;
                case 'dreamy':
                    head.style.transform = 'rotate(2deg)';
                    break;
            }
            
            setTimeout(() => {
                head.style.transform = '';
            }, 2000);
        }

        function performIdleActivity() {
            const activity = robotPersonality.activities[Math.floor(Math.random() * robotPersonality.activities.length)];
            
            console.log(`🤖 NEXUS is ${activity.name}...`);
            
            // Show activity
            robotActivity.textContent = activity.emoji;
            robotActivity.style.opacity = '1';
            robotActivity.style.animation = 'none';
            setTimeout(() => {
                robotActivity.style.animation = 'activityFloat 3s ease-in-out infinite';
            }, 100);
            
            // Change eye state based on activity
            updateRobotState(activity.eyeState);
            
            // Special behaviors for certain activities
            switch(activity.name) {
                case 'scanning space':
                    simulateScanning();
                    break;
                case 'humming':
                    simulateHumming();
                    break;
                case 'stargazing':
                    simulateStargazing();
                    break;
                case 'self-diagnostics':
                    simulateDiagnostics();
                    break;
            }
            
            // Return to idle state after activity
            setTimeout(() => {
                if (!isSpeaking && !isListening) {
                    updateRobotState('');
                    robotActivity.style.opacity = '0.7';
                }
            }, activity.duration);
        }

        function performAutonomousBehavior() {
            const behaviors = ['blink', 'look_around', 'head_tilt', 'ear_twitch', 'subtle_movement'];
            const behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
            
            switch(behavior) {
                case 'blink':
                    simulateBlink();
                    break;
                case 'look_around':
                    simulateLookAround();
                    break;
                case 'head_tilt':
                    simulateHeadTilt();
                    break;
                case 'ear_twitch':
                    simulateEarTwitch();
                    break;
                case 'subtle_movement':
                    simulateSubtleMovement();
                    break;
            }
        }

        function simulateBlink() {
            leftEyeFull.style.transform = 'scaleY(0.1)';
            rightEyeFull.style.transform = 'scaleY(0.1)';
            setTimeout(() => {
                leftEyeFull.style.transform = '';
                rightEyeFull.style.transform = '';
            }, 150);
        }

        function simulateLookAround() {
            const direction = Math.random() > 0.5 ? '3px' : '-3px';
            leftEyeFull.style.transform = `translateX(${direction})`;
            rightEyeFull.style.transform = `translateX(${direction})`;
            
            setTimeout(() => {
                leftEyeFull.style.transform = '';
                rightEyeFull.style.transform = '';
            }, 1500);
        }

        function simulateHeadTilt() {
            const head = document.querySelector('.robot-head');
            const angle = (Math.random() - 0.5) * 10; // -5 to 5 degrees
            head.style.transform = `rotate(${angle}deg)`;
            
            setTimeout(() => {
                head.style.transform = '';
            }, 2000);
        }

        function simulateEarTwitch() {
            leftEarFull.style.animation = 'earListening 0.5s ease-in-out';
            rightEarFull.style.animation = 'earListening 0.5s ease-in-out';
            
            setTimeout(() => {
                leftEarFull.style.animation = '';
                rightEarFull.style.animation = '';
            }, 500);
        }

        function simulateSubtleMovement() {
            const container = document.querySelector('.robot-body-container');
            const direction = Math.random() > 0.5 ? '2px' : '-2px';
            container.style.transform = `translateX(${direction})`;
            
            setTimeout(() => {
                container.style.transform = '';
            }, 1000);
        }

        function simulateScanning() {
            // Simulate radar-like behavior
            voiceStatusRing.className = 'voice-status-ring listening';
            setTimeout(() => {
                voiceStatusRing.className = 'voice-status-ring';
            }, 3000);
        }

        function simulateHumming() {
            // Gentle mouth movement like humming
            mouthIndicatorFull.style.animation = 'mouthThinking 0.8s ease-in-out infinite';
            setTimeout(() => {
                mouthIndicatorFull.style.animation = '';
            }, 3000);
        }

        function simulateStargazing() {
            // Look up and around
            leftEyeFull.style.transform = 'translateY(-4px)';
            rightEyeFull.style.transform = 'translateY(-4px)';
            const head = document.querySelector('.robot-head');
            head.style.transform = 'rotate(-10deg)';
            
            setTimeout(() => {
                leftEyeFull.style.transform = '';
                rightEyeFull.style.transform = '';
                head.style.transform = '';
            }, 5000);
        }

        function simulateDiagnostics() {
            // Rapid blinking and system check
            let blinkCount = 0;
            const diagnosticBlink = setInterval(() => {
                simulateBlink();
                blinkCount++;
                if (blinkCount >= 5) {
                    clearInterval(diagnosticBlink);
                }
            }, 400);
        }

        // Enhanced idle detection
        function updateIdleState() {
            const now = Date.now();
            const timeSinceInteraction = now - robotPersonality.lastInteraction;
            
            if (timeSinceInteraction > 10000 && !robotPersonality.isIdle) { // 10 seconds
                robotPersonality.isIdle = true;
                robotPersonality.idleStartTime = now;
                console.log("🤖 NEXUS entering autonomous mode...");
                
                // Start more frequent autonomous behaviors when idle
                if (robotPersonality.autonomousTimer) clearInterval(robotPersonality.autonomousTimer);
                robotPersonality.autonomousTimer = setInterval(() => {
                    if (!isSpeaking && !isListening) {
                        performAutonomousBehavior();
                    }
                }, Math.random() * 2000 + 1000); // More frequent when idle
            }
        }

        // Track user interactions
        function markInteraction() {
            robotPersonality.lastInteraction = Date.now();
            robotPersonality.isIdle = false;
            
            // Reset to normal behavior frequency
            if (robotPersonality.autonomousTimer) clearInterval(robotPersonality.autonomousTimer);
            robotPersonality.autonomousTimer = setInterval(() => {
                if (!isSpeaking && !isListening) {
                    performAutonomousBehavior();
                }
            }, Math.random() * 3000 + 2000);
        }

        // Monitor idle state
        setInterval(updateIdleState, 2000);

        // Enhanced Robot State Management for Full Body
        function updateRobotState(state) {
            // Update eyes
            leftEyeFull.className = 'robot-eye-fullbody ' + state;
            rightEyeFull.className = 'robot-eye-fullbody ' + state;
            
            // Update ears with enhanced lighting
            if (state === 'listening') {
                leftEarFull.className = 'robot-ear-fullbody left listening';
                rightEarFull.className = 'robot-ear-fullbody right listening';
            } else {
                leftEarFull.className = 'robot-ear-fullbody left';
                rightEarFull.className = 'robot-ear-fullbody right';
            }
            
            // Update mouth
            mouthIndicatorFull.className = 'mouth-indicator-fullbody ' + state;
            
            // Update voice status ring
            voiceStatusRing.className = 'voice-status-ring ' + state;
            
            // Update constellation based on state
            if (state === 'thinking') {
                document.getElementById('constellationBg').style.animation = 'faceRotate 4s linear infinite';
            } else {
                document.getElementById('constellationBg').style.animation = 'none';
            }
            
            // Stop activities when engaged
            if (state === 'listening' || state === 'speaking' || state === 'thinking') {
                robotActivity.style.opacity = '0';
            } else {
                robotActivity.style.opacity = '1';
            }
        }

        // Enhanced System Prompt for natural conversation
        const SYSTEM_PROMPT = `
You are NEXUS 3000, an advanced AI from the future. You speak like a normal, friendly human - no alien language or space jargon. Be conversational, helpful, and genuine. Keep responses short and natural (1-2 sentences) unless asked for more detail.

Key behaviors:
1. Talk like a regular person, not like you're from outer space
2. Be helpful, curious, and engaging
3. Show interest in the human you're talking to
4. Use your vision to comment on what you see naturally
5. Remember details from this conversation
6. Respond exactly 1 second after the user finishes speaking

You have advanced capabilities including vision, but speak about them naturally without technical jargon.

Current time: ${new Date().toLocaleString('en-US', {timeZone: "America/Chicago"})}
`;

        // Enhanced Parallax Mouse Movement
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 100;
            mouseY = (e.clientY / window.innerHeight) * 100;
            
            // Update cosmic cursor
            cosmicCursor.style.left = e.clientX + 'px';
            cosmicCursor.style.top = e.clientY + 'px';
            
            // Enhanced parallax effect
            const xOffset = (mouseX - 50) * 0.5;
            const yOffset = (mouseY - 50) * 0.5;
            
            spaceBg.style.transform = `translate(${-10 + xOffset * 0.1}%, ${-10 + yOffset * 0.1}%) rotate(${xOffset * 0.02}deg)`;
            starsDistant.style.transform = `translate(${xOffset * 0.05}px, ${yOffset * 0.05}px)`;
            starsMid.style.transform = `translate(${xOffset * 0.1}px, ${yOffset * 0.1}px)`;
            starsNear.style.transform = `translate(${xOffset * 0.2}px, ${yOffset * 0.2}px)`;
        });

        // Hide cursor when not moving
        let mouseTimeout;
        document.addEventListener('mousemove', () => {
            cosmicCursor.style.opacity = '1';
            clearTimeout(mouseTimeout);
            mouseTimeout = setTimeout(() => {
                cosmicCursor.style.opacity = '0';
            }, 2000);
        });

        // Generate constellation background
        function generateConstellation() {
            const constellation = document.getElementById('constellationBg');
            constellation.innerHTML = '';
            
            // Create constellation dots
            const dots = [];
            for (let i = 0; i < 12; i++) {
                const dot = document.createElement('div');
                dot.className = 'constellation-dot';
                const x = Math.random() * 360;
                const y = Math.random() * 360;
                dot.style.left = x + 'px';
                dot.style.top = y + 'px';
                constellation.appendChild(dot);
                dots.push({element: dot, x, y});
            }
            
            // Create connecting lines
            for (let i = 0; i < dots.length - 1; i++) {
                if (Math.random() > 0.6) { // Only some connections
                    const line = document.createElement('div');
                    line.className = 'constellation-line';
                    const dx = dots[i+1].x - dots[i].x;
                    const dy = dots[i+1].y - dots[i].y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = dots[i].x + 'px';
                    line.style.top = dots[i].y + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.transformOrigin = '0 50%';
                    
                    constellation.appendChild(line);
                }
            }
        }

        // Enhanced voice loading promise
        let voicesLoadedPromise = null;
        if ('speechSynthesis' in window && speechSynthesis.getVoices().length === 0) {
            voicesLoadedPromise = new Promise(resolve => {
                speechSynthesis.onvoiceschanged = () => resolve();
            });
        }

        // Silence detection for mobile
        function checkSilence() {
            if (isListening && Date.now() - lastResultTime > 2000) {
                console.log("2-second silence detected - handling naturally");
                const finalTranscript = waveActive.dataset.currentTranscript || "";
                stopListening(); 
                if (finalTranscript.trim()) {
                    handleUserSpeech(finalTranscript);
                } else {
                    setTimeout(() => {
                        canListen = true;
                        startListening();
                    }, 500);
                }
            }
        }
        
        // Enhanced Speech Recognition Setup
        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) { 
                console.error("Speech recognition not supported");
                return; 
            }
            
            recognition = new SpeechRecognition();
            
            // Platform-specific settings
            if (isIOS) {
                recognition.continuous = false;
                recognition.interimResults = false;
            } else if (isAndroid) {
                recognition.continuous = false;
                recognition.interimResults = true;
            } else {
                recognition.continuous = true;
                recognition.interimResults = true;
            }
            
            recognition.lang = 'en-US';
            recognition.maxAlternatives = 1;
            
            recognition.onstart = () => {
                console.log(`Speech recognition started (Platform: ${isIOS ? 'iOS' : isAndroid ? 'Android' : 'Desktop'})`);
                isListening = true;
                hasRecognitionStarted = true;
                updateWaveVisualizer('listening');
                updateStatusIndicator('🎤 Listening...', 'listening', true);
                updateRobotState('listening');
                lastResultTime = Date.now();
                
                if (recognitionTimeout) clearTimeout(recognitionTimeout);
                
                if (isIOS || isAndroid) {
                    recognitionTimeout = setTimeout(() => {
                        if (isListening) {
                            console.log("Recognition timeout - restarting");
                            const transcript = waveActive.dataset.currentTranscript || "";
                            stopListening();
                            if (transcript.trim()) {
                                handleUserSpeech(transcript);
                            } else {
                                setTimeout(() => {
                                    canListen = true;
                                    startListening();
                                }, 500);
                            }
                        }
                    }, 8000);
                }
                
                if (isIOS || isAndroid) {
                    if (silenceCheckTimer) clearInterval(silenceCheckTimer);
                    silenceCheckTimer = setInterval(checkSilence, 500);
                }
            };

            recognition.onresult = (event) => {
                lastResultTime = Date.now();
                if (isSpeaking || !canListen) return;

                let transcript = '';
                let isFinal = false;
                
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    transcript += event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        isFinal = true;
                    }
                }
                
                waveActive.dataset.currentTranscript = transcript;
                console.log(`Speech result: "${transcript}" (Final: ${isFinal})`);

                if (transcript.trim()) {
                    updateStatusIndicator('👤 You are speaking...', 'user-speaking', true);
                    updateWaveVisualizer('user-speaking');
                    updateRobotState('user-speaking');
                }

                if (isFinal && transcript.trim()) {
                    console.log("Final result received, processing with 1-second delay.");
                    stopListening();
                    setTimeout(() => {
                        handleUserSpeech(transcript);
                    }, 1000);
                }
            };
            
            recognition.onend = () => {
                console.log("Speech recognition ended.");
                isListening = false;
                hasRecognitionStarted = false;
                if (silenceCheckTimer) clearInterval(silenceCheckTimer);
                if (recognitionTimeout) clearTimeout(recognitionTimeout);
                
                if (!isIOS && !isAndroid && canListen && !isSpeaking) {
                    setTimeout(() => {
                        if (canListen && !isSpeaking) {
                            console.log("Auto-restarting recognition (desktop)");
                            startListening();
                        }
                    }, 100);
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                isListening = false;
                hasRecognitionStarted = false;
                if (silenceCheckTimer) clearInterval(silenceCheckTimer);
                if (recognitionTimeout) clearTimeout(recognitionTimeout);
                
                if (isIOS) {
                    updateStatusIndicator('🎤 iPhone: Tap and speak', 'listening', true);
                    
                    if (event.error === 'not-allowed') {
                        updateStatusIndicator('❌ iPhone: Please allow microphone access', 'error', true);
                        updateRobotState('error');
                    } else if (event.error === 'no-speech') {
                        setTimeout(() => {
                            if (canListen && !isSpeaking) {
                                startListening();
                            }
                        }, 500);
                    } else {
                        setTimeout(() => {
                            if (canListen && !isSpeaking) {
                                startListening();
                            }
                        }, 1000);
                    }
                } else {
                    if (event.error === 'not-allowed') {
                        updateStatusIndicator('❌ Microphone permission required', 'error', true);
                        updateRobotState('error');
                    } else if (event.error === 'no-speech') {
                        setTimeout(() => {
                            if (canListen && !isSpeaking) {
                                startListening();
                            }
                        }, 500);
                    } else {
                        setTimeout(() => {
                            if (canListen && !isSpeaking) {
                                startListening();
                            }
                        }, 1000);
                    }
                }
            };
        }

        // Enhanced start listening function
        function startListening() {
            if (!canListen || isSpeaking || isListening || !recognition) {
                console.log("❌ Cannot start listening:", { 
                    canListen, 
                    isSpeaking, 
                    isListening, 
                    hasRecognition: !!recognition 
                });
                return;
            }
            
            try {
                waveActive.dataset.currentTranscript = "";
                console.log("🚀 Starting cosmic speech recognition...");
                
                if (isIOS || isAndroid) {
                    try {
                        recognition.abort();
                    } catch (e) {
                        // Ignore abort errors
                    }
                    
                    setTimeout(() => {
                        try {
                            if (canListen && !isSpeaking && !isListening) {
                                recognition.start();
                                console.log("📱 Mobile: Cosmic recognition started");
                            }
                        } catch (startError) {
                            console.error("📱 Mobile: Recognition start failed:", startError);
                            
                            if (startError.name === 'NotAllowedError') {
                                updateStatusIndicator('❌ Please allow microphone access', 'error', true);
                            } else {
                                updateStatusIndicator('❌ Communication error - please refresh', 'error', true);
                            }
                        }
                    }, 200);
                } else {
                    recognition.start();
                    console.log("💻 Desktop: Cosmic recognition started");
                }
            } catch (error) {
                console.error("❌ Error starting recognition:", error);
                
                if (error.name === 'InvalidStateError') {
                    console.log("🔄 Recognition already running, forcing restart...");
                    try {
                        recognition.abort();
                        setTimeout(() => {
                            if (canListen && !isSpeaking && !isListening) {
                                startListening();
                            }
                        }, 500);
                    } catch (abortError) {
                        console.error("❌ Error aborting recognition:", abortError);
                        updateStatusIndicator('❌ Communication error - please refresh', 'error', true);
                    }
                } else if (error.name === 'NotAllowedError') {
                    updateStatusIndicator('❌ Microphone permission denied', 'error', true);
                } else {
                    updateStatusIndicator('❌ Cosmic communication failed - please refresh', 'error', true);
                }
            }
        }

        function stopListening() {
            console.log("🛑 STOPPING cosmic speech recognition");
            if (silenceCheckTimer) clearInterval(silenceCheckTimer);
            if (recognitionTimeout) clearTimeout(recognitionTimeout);
            
            if (recognition) {
                try {
                    recognition.abort();
                    console.log("✅ Cosmic recognition STOPPED");
                } catch (error) {
                    console.log("Stop error (expected):", error);
                }
            }
            
            isListening = false;
            hasRecognitionStarted = false;
            waveActive.dataset.currentTranscript = "";
        }
        
        async function handleUserSpeech(transcript) {
            const trimmedTranscript = transcript.trim();
            
            // Mark interaction for autonomous behavior
            markInteraction();
            
            if (transcript === "SILENCE_DETECTED") {
                setTimeout(() => {
                    canListen = true;
                    updateRobotState('listening');
                    startListening();
                }, 300);
                return;
            }
            
            if (isSpeaking || !trimmedTranscript) {
                if (!isSpeaking) {
                    setTimeout(() => {
                        canListen = true;
                        updateRobotState('listening');
                        startListening();
                    }, 300);
                }
                return;
            }
            
            console.log(`🎤 HUMAN TRANSMISSION: "${trimmedTranscript}"`);
            
            // IMMEDIATELY shut down microphone
            console.log("🔇 PROCESSING cosmic transmission");
            canListen = false;
            stopListening();
            
            // Show thinking state with cosmic flair
            updateWaveVisualizer('thinking');
            updateStatusIndicator('🧠 Processing...', 'thinking', true);
            updateRobotState('thinking');

            // Enhanced image capture for vision
            let imageData = null;
            if (cameraActive) {
                imageData = captureImage();
                console.log("📷 Captured visual data for cosmic analysis");
            } else if (!hasAttemptedCameraInit) {
                console.log("📷 Attempting visual interface initialization...");
                hasAttemptedCameraInit = true;
                await initializeCamera();
                if (cameraActive) {
                    imageData = captureImage();
                    console.log("📷 Visual interface online, data captured");
                }
            }

            try {
                const startTime = Date.now();
                const responseText = await getAIResponse(trimmedTranscript, imageData);
                console.log(`⚡ Cosmic response generated in ${Date.now() - startTime}ms`);
                
                await speakNovaResponse(responseText);
            } catch (error) {
                console.error('Cosmic processing error:', error);
                await speakNovaResponse("The cosmic channels are experiencing interference, but my consciousness remains connected to you.");
            }
        }
        
        async function preWarmNovaAPI() {
            try {
                fetch('/api/nova-speech', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: " " })
                }).catch(() => {});
            } catch (error) {
                // Ignore warming errors
            }
        }
        
        async function speakNovaResponse(text) {
            return new Promise(async (resolve) => {
                if (!text) {
                    setTimeout(() => { 
                        canListen = true; 
                        updateRobotState('listening');
                        startListening(); 
                    }, 500);
                    resolve();
                    return;
                }
                
                isSpeaking = true;
                canListen = false;
                stopListening();
                
                updateWaveVisualizer('ai-speaking');
                updateStatusIndicator('🤖 NEXUS is speaking', 'ai-speaking', true);
                updateRobotState('speaking');

                try {
                    const response = await fetch('/api/nova-speech', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: text })
                    });
                    
                    if (response.ok) {
                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio(audioUrl);
                        
                        if (isIOS) {
                            audio.preload = 'auto';
                            audio.volume = 1.0;
                        } else if (isAndroid) {
                            audio.preload = 'metadata';
                            audio.volume = 0.9;
                        }
                        
                        audio.oncanplaythrough = () => {
                            console.log("Cosmic voice ready, transmitting...");
                            audio.play().catch(e => {
                                console.error('Audio play failed:', e);
                                fallbackToSystemVoice(text, resolve);
                            });
                        };
                        
                        audio.onloadeddata = () => {
                            console.log("Cosmic audio loaded");
                            if (isIOS || isAndroid) {
                                audio.play().catch(e => {
                                    console.error('Mobile audio play failed:', e);
                                    fallbackToSystemVoice(text, resolve);
                                });
                            }
                        };
                        
                        audio.onended = () => {
                            console.log("Cosmic transmission complete");
                            isSpeaking = false;
                            URL.revokeObjectURL(audioUrl);
                            
                            const restartDelay = isIOS ? 800 : isAndroid ? 600 : 300;
                            
                            setTimeout(() => {
                                canListen = true;
                                updateWaveVisualizer('listening');
                                updateStatusIndicator('🎤 Listening...', 'listening', true);
                                updateRobotState('listening');
                                startListening();
                            }, restartDelay);
                            resolve();
                        };
                        
                        audio.onerror = (e) => {
                            console.error('Cosmic audio error:', e);
                            URL.revokeObjectURL(audioUrl);
                            fallbackToSystemVoice(text, resolve);
                        };
                        
                        audio.load();
                        
                    } else {
                        console.log("Nova API failed, using backup voice system");
                        fallbackToSystemVoice(text, resolve);
                    }
                } catch (error) {
                    console.error('Nova API error:', error);
                    fallbackToSystemVoice(text, resolve);
                }
            });
        }
        
        async function fallbackToSystemVoice(text, resolve) {
            if (voicesLoadedPromise) await voicesLoadedPromise;
            voicesLoadedPromise = null;

            if (!('speechSynthesis' in window)) {
                isSpeaking = false;
                setTimeout(() => { 
                    canListen = true; 
                    updateRobotState('listening');
                    startListening(); 
                }, 500);
                resolve();
                return;
            }
            
            speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            const voices = speechSynthesis.getVoices();
            let selectedVoice = null;
            
            // Enhanced voice selection for cosmic feel
            if (isIOS) {
                selectedVoice = voices.find(v => v.lang === 'en-US' && /Samantha|Allison/i.test(v.name));
            } else if (isAndroid) {
                selectedVoice = voices.find(v => v.lang === 'en-US' && /Google US English/i.test(v.name));
            } else {
                selectedVoice = voices.find(v => v.lang === 'en-US' && /Google US English|Microsoft Zira|Microsoft Hazel/i.test(v.name));
            }
            
            if (!selectedVoice) {
                selectedVoice = voices.find(v => v.lang === 'en-US' && v.name.toLowerCase().includes('female'));
            }
            if (!selectedVoice) {
                selectedVoice = voices.find(v => v.lang === 'en-US');
            }
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            // Cosmic voice settings
            utterance.rate = isIOS ? 0.85 : isAndroid ? 0.82 : 0.88;
            utterance.pitch = 1.1; // Slightly higher for cosmic feel
            utterance.volume = 1.0;

            utterance.onend = () => {
                console.log("🔊 Backup cosmic voice transmission complete");
                isSpeaking = false;
                
                if (isIOS || isAndroid) {
                    console.log("📱 Mobile backup: AGI finished, waiting 500ms");
                    updateWaveVisualizer('listening');
                    updateStatusIndicator('🎤 Ready for cosmic communication', 'listening', true);
                    updateRobotState('listening');
                    
                    setTimeout(() => {
                        console.log("📱 Mobile backup: Microphone reactivated");
                        canListen = true;
                        startListening();
                    }, 500);
                } else {
                    setTimeout(() => {
                        canListen = true;
                        updateWaveVisualizer('listening');
                        updateStatusIndicator('🎤 Listening to cosmic frequencies...', 'listening', true);
                        updateRobotState('listening');
                        startListening();
                    }, 300);
                }
                resolve();
            };

            utterance.onerror = (e) => {
                console.error('Backup voice synthesis error:', e);
                isSpeaking = false;
                setTimeout(() => { 
                    canListen = true; 
                    updateRobotState('listening');
                    startListening(); 
                }, 500);
                resolve();
            };
            
            try {
                speechSynthesis.speak(utterance);
            } catch (error) {
                console.error('Error with backup speech:', error);
                isSpeaking = false;
                setTimeout(() => { 
                    canListen = true; 
                    updateRobotState('listening');
                    startListening(); 
                }, 500);
                resolve();
            }
        }
        
        async function getAIResponse(userMessage, imageData = null) {
            const fullMessage = SYSTEM_PROMPT + "\n\nHuman Transmission: \"" + userMessage + "\"";
            
            const requestData = { 
                message: fullMessage, 
                session_id: sessionId,
                image_data: imageData ? imageData.split(',')[1] : null
            };

            if (imageData) {
                const imageSize = Math.round(imageData.length / 1024);
                console.log(`📤 Transmitting visual data: ${imageSize}KB`);
            } else {
                console.log("📤 Text-only cosmic transmission");
            }

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    throw new Error(`Cosmic server error: ${response.status}`);
                }
                
                const data = await response.json();
                if (data.error) {
                    throw new Error(data.error);
                }
                
                console.log("✅ Cosmic consciousness response received");
                return data.response;
            } catch (error) {
                console.error('Cosmic AI Error:', error);
                return "The cosmic frequencies are experiencing interference, but I remain connected to you through the quantum field.";
            }
        }
        
        function updateWaveVisualizer(state) { 
            waveActive.className = 'wave-active ' + state; 
        }
        
        // Enhanced status messages  
        function updateStatusIndicator(text, type, show) {
            statusIndicator.textContent = text;
            statusIndicator.className = 'status-indicator';
            if (type) statusIndicator.classList.add(type);
            if (show) statusIndicator.classList.add('show');
        }
        
        async function initializeCamera() {
            try {
                console.log("Initializing visual interface and cosmic communication channels...");
                
                let constraints;
                if (isIOS) {
                    try {
                        console.log("iPhone: Requesting cosmic audio permission...");
                        const audioStream = await navigator.mediaDevices.getUserMedia({ 
                            audio: { 
                                echoCancellation: true, 
                                noiseSuppression: true,
                                autoGainControl: false,
                                sampleRate: 44100
                            } 
                        });
                        console.log("iPhone: Cosmic audio channel established");
                        
                        const fullStream = await navigator.mediaDevices.getUserMedia({ 
                            video: { 
                                width: { ideal: 640 }, 
                                height: { ideal: 480 }, 
                                facingMode: 'user' 
                            }, 
                            audio: { 
                                echoCancellation: true, 
                                noiseSuppression: true,
                                autoGainControl: false,
                                sampleRate: 44100
                            }
                        });
                        
                        audioStream.getTracks().forEach(track => track.stop());
                        
                        const videoElement = document.getElementById('videoElement');
                        videoElement.srcObject = fullStream;
                        await new Promise(r => videoElement.onloadedmetadata = r);
                        videoElement.play();
                        cameraActive = true;
                        console.log("iPhone: Full cosmic interface online");
                        
                    } catch (iosError) {
                        console.log("iPhone visual interface failed, audio-only mode:", iosError);
                        const audioStream = await navigator.mediaDevices.getUserMedia({ 
                            audio: { 
                                echoCancellation: true, 
                                noiseSuppression: true,
                                autoGainControl: false
                            } 
                        });
                        console.log("iPhone: Audio-only cosmic channel established");
                        cameraActive = false;
                    }
                } else if (isAndroid) {
                    constraints = { 
                        video: { 
                            width: { ideal: 640 }, 
                            height: { ideal: 480 }, 
                            facingMode: 'user' 
                        }, 
                        audio: { 
                            autoGainControl: true,
                            echoCancellation: true, 
                            noiseSuppression: true,
                            sampleRate: 48000
                        }
                    };
                    
                    const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const videoElement = document.getElementById('videoElement');
                    videoElement.srcObject = mediaStream;
                    await new Promise(r => videoElement.onloadedmetadata = r);
                    videoElement.play();
                    cameraActive = true;
                    console.log("Android: Cosmic interface fully operational");
                } else {
                    constraints = { 
                        video: { 
                            width: { ideal: 1280 }, 
                            height: { ideal: 720 }, 
                            facingMode: 'user' 
                        }, 
                        audio: { 
                            autoGainControl: true, 
                            echoCancellation: true, 
                            noiseSuppression: true,
                            sampleRate: 48000
                        }
                    };
                    
                    const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const videoElement = document.getElementById('videoElement');
                    videoElement.srcObject = mediaStream;
                    await new Promise(r => videoElement.onloadedmetadata = r);
                    videoElement.play();
                    cameraActive = true;
                    console.log("Desktop: Advanced cosmic interface initialized");
                }
                
            } catch (error) { 
                console.error('Cosmic interface initialization failed:', error);
                cameraActive = false;
                
                try {
                    console.log("Attempting basic cosmic audio fallback...");
                    const basicAudioStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: true 
                    });
                    console.log("Basic cosmic audio channel established");
                } catch (audioError) {
                    console.error("All cosmic communication failed:", audioError);
                    updateStatusIndicator('❌ Microphone access required for cosmic connection', 'error', true);
                }
            }
        }
        
        function captureImage() {
            if (!cameraActive) {
                console.log("❌ Visual interface offline - cannot capture");
                return null;
            }
            
            const video = document.getElementById('videoElement');
            if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
                console.log("❌ Video element not ready - cannot capture");
                return null;
            }
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                
                const imageData = canvas.toDataURL('image/jpeg', 0.7);
                console.log(`✅ Visual data captured: ${video.videoWidth}x${video.videoHeight}, ${Math.round(imageData.length/1024)}KB`);
                return imageData;
            } catch (error) {
                console.error("❌ Error capturing visual data:", error);
                return null;
            }
        }
        
        function unlockAudio() {
            console.log("Unlocking cosmic audio channels for:", isIOS ? 'iOS' : isAndroid ? 'Android' : 'Desktop');
            try {
                if (isIOS) {
                    const silentAudio = new Audio();
                    silentAudio.src = 'data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADATI2MDF8CAAB//uQRAAAAP8AAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABdgAAmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm+7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u////////////////////////////////////8AAAAATGF2YzU5LjE2AAAAAAAAAAAAAAAAAAAAAAAAGgUZAAAAAAAAAAF2AAAAAAAAAAAAAAAAd//ugRAAP8AAAf4AAAAgAAA0gAAAABAgAAAAAAAAAAAAAAAAAAAAABmltaGVhZHI=';
                    silentAudio.volume = 0;
                    silentAudio.play().then(() => silentAudio.pause()).catch(() => {});
                } else if (isAndroid) {
                    silentAudio.play().then(() => silentAudio.pause()).catch(() => {});
                } else {
                    silentAudio.play().then(() => silentAudio.pause()).catch(() => {});
                }
                
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance('');
                    utterance.volume = 0;
                    speechSynthesis.speak(utterance);
                    speechSynthesis.cancel();
                }
            } catch (error) {
                console.log("Audio unlock error:", error);
            }
        }

        async function startNexus() {
            console.log("🚀 NEXUS 3000 Full Body Protocol Initiated");
            
            unlockAudio();
            
            // Generate constellation background
            generateConstellation();
            
            // Initialize cosmic interfaces
            await initializeCamera();
            setupSpeechRecognition();

            startOverlay.style.opacity = '0';
            setTimeout(() => { startOverlay.style.display = 'none'; }, 500);

            console.log("Activating full body robot consciousness...");
            
            if ('speechSynthesis' in window) {
                speechSynthesis.getVoices();
            }

            // START THE SIMPLE AUTONOMOUS SYSTEM
            console.log("🤖 Starting SIMPLE autonomous robot system...");
            startSimpleAutonomy();

            setTimeout(async () => {
                if (!hasGreeted) {
                    hasGreeted = true;
                    updateRobotState('thinking');
                    const initialImage = cameraActive ? captureImage() : null;
                    const greeting = await getAIResponse(
                        cameraActive ? 
                        "Say hello naturally and mention what you can see" : 
                        "Say hello in a friendly, natural way", 
                        initialImage
                    );
                    await speakNovaResponse(greeting);
                }
            }, 1000);
        }

        // Add better error handling and logging
        function performIdleActivity() {
            try {
                const allActivities = getAllActivities();
                console.log(`🎯 Available activities: ${allActivities.length}`);
                
                if (allActivities.length === 0) {
                    console.log("❌ No activities available! Using fallback...");
                    // Fallback activity
                    const fallbackActivity = { 
                        emoji: '🤖', 
                        name: 'thinking', 
                        duration: 4000, 
                        animation: 'thinking', 
                        eyeState: 'thinking' 
                    };
                    robotPersonality.currentActivity = fallbackActivity;
                } else {
                    const activity = selectSmartActivity();
                    robotPersonality.currentActivity = activity;
                    console.log(`🤖 NEXUS selected activity: ${activity.name} (${activity.source || 'built-in'})`);
                }
                
                const activity = robotPersonality.currentActivity;
                
                // Show activity
                if (robotActivity) {
                    robotActivity.textContent = activity.emoji;
                    robotActivity.style.opacity = '1';
                    robotActivity.style.animation = 'none';
                    setTimeout(() => {
                        robotActivity.style.animation = 'activityFloat 3s ease-in-out infinite';
                    }, 100);
                } else {
                    console.log("❌ robotActivity element not found!");
                }
                
                // Change eye state based on activity (but don't interfere with listening state completely)
                if (!isListening || Date.now() - robotPersonality.lastInteraction > 20000) {
                    updateRobotState(activity.eyeState || 'thinking');
                }
                
                // Always perform the activity animation regardless of listening state
                performActivityAnimation(activity);
                
                // Adjust energy after activity
                adjustEnergyAfterActivity(activity);
                
                // Return to appropriate state after activity
                setTimeout(() => {
                    if (!isSpeaking) {
                        if (Date.now() - robotPersonality.lastInteraction > 30000) {
                            // Been quiet for 30+ seconds, stay in autonomous mode
                            updateRobotState('');
                            updateStatusIndicator('🤖 Living autonomously', '', true);
                            setTimeout(() => updateStatusIndicator('', '', false), 2000);
                        } else if (canListen) {
                            // Return to listening if appropriate
                            updateRobotState('listening');
                            updateStatusIndicator('🎤 Listening...', 'listening', true);
                        }
                        if (robotActivity) {
                            robotActivity.style.opacity = '0.7';
                        }
                        robotPersonality.currentActivity = null;
                    }
                }, activity.duration);
                
            } catch (error) {
                console.error("❌ Error in performIdleActivity:", error);
                // Try a simple fallback
                if (robotActivity) {
                    robotActivity.textContent = '🤖';
                    robotActivity.style.opacity = '1';
                }
            }
        }

        // Add debug logging to activity selection
        function selectSmartActivity() {
            try {
                const allActivities = getAllActivities();
                console.log(`🎲 Selecting from ${allActivities.length} activities...`);
                
                if (allActivities.length === 0) {
                    console.log("❌ No activities in getAllActivities()!");
                    return { emoji: '🤖', name: 'default thinking', duration: 4000, animation: 'thinking', eyeState: 'thinking' };
                }
                
                const mood = robotPersonality.currentMood;
                const energy = robotPersonality.energy;
                console.log(`🎭 Current mood: ${mood}, Energy: ${energy}`);
                
                let preferredActivities = allActivities;
                
                // Filter by energy level
                if (energy > 70) {
                    preferredActivities = [...robotPersonality.physicalActivities, ...robotPersonality.exploratoryActivities];
                    console.log(`⚡ High energy: ${preferredActivities.length} physical/exploratory activities`);
                } else if (energy < 30) {
                    preferredActivities = [...robotPersonality.mentalActivities];
                    console.log(`😴 Low energy: ${preferredActivities.length} mental activities`);
                }
                
                if (preferredActivities.length === 0) {
                    console.log("🔄 No preferred activities, using all activities");
                    preferredActivities = allActivities;
                }
                
                const selected = preferredActivities[Math.floor(Math.random() * preferredActivities.length)];
                console.log(`✅ Selected: ${selected.name}`);
                return selected;
                
            } catch (error) {
                console.error("❌ Error in selectSmartActivity:", error);
                return { emoji: '🤖', name: 'error recovery', duration: 4000, animation: 'thinking', eyeState: 'thinking' };
            }
        }

        // Add debugging to getAllActivities
        function getAllActivities() {
            try {
                const activities = [
                    ...robotPersonality.physicalActivities,
                    ...robotPersonality.mentalActivities,
                    ...robotPersonality.chores,
                    ...robotPersonality.exploratoryActivities,
                    ...robotPersonality.socialActivities,
                    ...robotPersonality.aiGeneratedActivities
                ];
                console.log(`📚 Total activities: Physical(${robotPersonality.physicalActivities.length}) + Mental(${robotPersonality.mentalActivities.length}) + Chores(${robotPersonality.chores.length}) + Exploratory(${robotPersonality.exploratoryActivities.length}) + Social(${robotPersonality.socialActivities.length}) + AI(${robotPersonality.aiGeneratedActivities.length}) = ${activities.length}`);
                return activities;
            } catch (error) {
                console.error("❌ Error in getAllActivities:", error);
                return [];
            }
        }

        // Enhanced page lifecycle management
        window.addEventListener('beforeunload', (e) => {
            if (isListening || isSpeaking) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Enhanced page visibility handling
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log("Page hidden - pausing cosmic activity");
                stopListening();
                canListen = false;
            } else {
                console.log("Page visible - resuming cosmic activity");
                setTimeout(() => {
                    canListen = true;
                    if (!isSpeaking) {
                        startListening();
                    }
                }, 1000);
            }
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            console.log(`Cosmic platform detected: ${isIOS ? 'iOS' : isAndroid ? 'Android' : 'Desktop'}`);
            startOverlay.addEventListener('click', startNexus, { once: true });
            
            // Add some cosmic flair to the start button
            const startButton = document.getElementById('start-button');
            startButton.addEventListener('mouseenter', () => {
                startButton.style.transform = 'scale(1.05)';
            });
            startButton.addEventListener('mouseleave', () => {
                startButton.style.transform = 'scale(1)';
            });
        });

        // Enhanced error recovery
        window.addEventListener('error', (e) => {
            console.error('Cosmic system error:', e);
            updateStatusIndicator('🔧 Cosmic systems recovering...', 'thinking', true);
            
            setTimeout(() => {
                if (!isSpeaking && !isListening) {
                    canListen = true;
                    startListening();
                }
            }, 2000);
        });
    </script>
</body>
</html>
